use std::any::TypeId;
use std::collections::HashMap;
use std::error::Error;
use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;
use std::any::Any;
use futures::future::BoxFuture;

type AnyFactoryFn = Arc<dyn FnOnce() -> BoxFuture<'static, Result<Box<dyn Any>, Box<dyn Error + Send + Sync>>>>;
type FactoryFn<T> = Arc<dyn FnOnce() -> BoxFuture<'static, Result<Box<T>, Box<dyn Error + Send + Sync>>>>;

struct Factory {
    factory: AnyFactoryFn,
    value: Option<Result<Box<dyn Any>, Box<dyn Error + Send + Sync>>>,
}

impl Future for Factory {
    type Output = Result<Box<dyn Any>, Box<dyn Error + Send + Sync>>;

    fn poll(mut self: Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
        let this = &mut *self;

        if let Some(result) = this.value.take() {
            return std::task::Poll::Ready(result);
        }

        // Call the factory function
        let mut future = (this.factory)();

        // Poll the future
        match future.poll(cx) {
            std::task::Poll::Ready(value) => {
                this.value = Some(value);
                std::task::Poll::Ready(this.value.as_ref().unwrap())
            }
            std::task::Poll::Pending => std::task::Poll::Pending,
        }
    }
}

pub struct Registry {
    modules: HashMap<TypeId, Factory>,
}

impl Registry {
    pub fn new() -> Self {
        Registry {
            modules: HashMap::new(),
        }
    }

    pub fn register<T>(&mut self, factory: FactoryFn<T>)
    where
        T: 'static,
    {
        self.modules.insert(TypeId::of::<T>(), Factory {
            factory,
            value: None,
        });
    }

    pub fn provide<T>(&self) -> Option<Pin<Box<dyn Future<Output = &T>>>>
    where
        T: 'static,
    {
        if let Some(factory) = self.modules.get(&TypeId::of::<T>()) {
            let future = Factory {
                factory: factory.factory.clone(),
                value: None,
            };
            Some(Box::pin(future))
        } else {
            None
        }
    }
}
